import type { DebugSession } from "./session.ts";

export async function continueExecution(session: DebugSession): Promise<void> {
	if (!session.isPaused()) {
		throw new Error("Cannot continue: process is not paused");
	}
	if (!session.cdp) {
		throw new Error("Cannot continue: no CDP connection");
	}
	const waiter = session.createPauseWaiter();
	await session.cdp.send("Debugger.resume");
	await waiter;
}

export async function stepExecution(
	session: DebugSession,
	mode: "over" | "into" | "out",
): Promise<void> {
	if (!session.isPaused()) {
		throw new Error("Cannot step: process is not paused");
	}
	if (!session.cdp) {
		throw new Error("Cannot step: no CDP connection");
	}

	const methodMap = {
		over: "Debugger.stepOver",
		into: "Debugger.stepInto",
		out: "Debugger.stepOut",
	} as const;

	const waiter = session.createPauseWaiter();
	await session.cdp.send(methodMap[mode]);
	await waiter;
}

export async function pauseExecution(session: DebugSession): Promise<void> {
	if (session.sessionState !== "running") {
		throw new Error("Cannot pause: process is not running");
	}
	if (!session.cdp) {
		throw new Error("Cannot pause: no CDP connection");
	}
	const waiter = session.createPauseWaiter();
	await session.cdp.send("Debugger.pause");
	await waiter;
}

export async function runToLocation(
	session: DebugSession,
	file: string,
	line: number,
): Promise<void> {
	if (!session.isPaused()) {
		throw new Error("Cannot run-to: process is not paused");
	}
	if (!session.cdp) {
		throw new Error("Cannot run-to: no CDP connection");
	}

	// Find the script URL matching the given file (by suffix)
	const scriptUrl = session.findScriptUrl(file);
	if (!scriptUrl) {
		throw new Error(`Cannot run-to: no loaded script matches "${file}"`);
	}

	// Set a temporary breakpoint (CDP lines are 0-based)
	const bpResult = await session.cdp.send("Debugger.setBreakpointByUrl", {
		lineNumber: line - 1,
		urlRegex: scriptUrl.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
	});

	const breakpointId = bpResult.breakpointId;

	// Resume execution â€” set up waiter before sending resume
	const waiter = session.createPauseWaiter();
	await session.cdp.send("Debugger.resume");
	await waiter;

	// Remove the temporary breakpoint
	if (breakpointId && session.cdp) {
		try {
			await session.cdp.send("Debugger.removeBreakpoint", { breakpointId });
		} catch {
			// Breakpoint may already be gone if process exited
		}
	}
}

export async function restartFrameExecution(
	session: DebugSession,
	frameRef?: string,
): Promise<{ status: string }> {
	if (!session.isPaused()) {
		throw new Error("Cannot restart frame: process is not paused");
	}
	if (!session.cdp) {
		throw new Error("Cannot restart frame: no CDP connection");
	}

	let callFrameId: string;
	if (frameRef) {
		const entry = session.refs.resolve(frameRef);
		if (!entry) {
			throw new Error(`Unknown frame ref: ${frameRef}`);
		}
		callFrameId = entry.remoteId;
	} else {
		const topFrame = session.pausedCallFrames[0];
		if (!topFrame) {
			throw new Error("No call frames available");
		}
		callFrameId = topFrame.callFrameId;
	}

	const waiter = session.createPauseWaiter();
	await session.cdp.send("Debugger.restartFrame", { callFrameId, mode: "StepInto" });
	await waiter;

	return { status: "restarted" };
}
